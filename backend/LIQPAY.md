# Инструкция по интеграции LiqPay в бэкенд

## 1. Настройка окружения
1. Получите публичный и приватный ключи мерчанта в кабинете LiqPay.
2. Добавьте их в `.env` (см. пример `.env.example`):
   ```bash
   LIQPAY_PUBLIC_KEY=<публичный_ключ>
   LIQPAY_PRIVATE_KEY=<приватный_ключ>
   # Опционально, код валюты (по умолчанию `UAH`)
   LIQPAY_CURRENCY=UAH
   ```
3. Перезапустите контейнер `backend` (или локальный сервер), чтобы переменные подхватились.

## 2. Получение плейлода для платежа
1. Бэкенд рассчитывает задолженность заказа и формирует payload LiqPay в эндпоинте `POST /public/purchase/{purchase_id}/pay`.
2. Запрос должен выполняться из публичного контекста покупки: cookie выдаётся при открытии публичной страницы покупки или билета и затем повторно используется для оплаты.
3. В ответе придёт структура:
   ```json
   {
     "provider": "liqpay",
     "data": "<base64>",
     "signature": "<base64>",
     "payload": {
       "version": "3",
       "public_key": "...",
       "action": "pay",
       "amount": 100.0,
       "currency": "UAH",
       "description": "Purchase #15",
       "order_id": "purchase-15",
       "result_url": "http://frontend/purchase/15"
     }
   }
   ```
   - `amount` — сумма к оплате с учётом задолженности заказа.
   - `order_id` принимает вид `purchase-{purchase_id}` или `ticket-{ticket_id}-{purchase_id}` при оплате конкретного билета.
   - `result_url` указывает на страницу, куда LiqPay вернёт пользователя после оплаты.


### Дополнительно: endpoint `/pay`
`POST /pay` также может вернуть LiqPay payload для внешнего фронтенда, если запрос выполнен **без** админского Bearer-токена.
Если в запросе есть валидный админский токен, endpoint работает как офлайн-оплата сотрудником и сразу переводит заказ в `paid` без LiqPay.

## 3. Отправка формы в LiqPay
1. На фронтенде сформируйте форму `POST` на `https://www.liqpay.ua/api/3/checkout` с полями `data` и `signature` из ответа.
2. Дополнительные поля (`language`, `sandbox`, `iframe`) LiqPay берёт из `data`, поэтому их добавление следует делать на стороне бэкенда перед подписью при необходимости.
3. После сабмита LiqPay перенаправит пользователя на `result_url`; убедитесь, что URL указывает на фронтенд вашего проекта.

## 4. Настройка страницы возврата (redirect)
`result_url` всегда строится от `CLIENT_APP_BASE` (или `APP_PUBLIC_URL`) в формате:

`{CLIENT_APP_BASE}/purchase/{purchase_id}`

Важно:
- `CLIENT_APP_BASE` обязателен для формирования ссылок.
- Значения `localhost/127.0.0.1/::1` не допускаются (защита от некорректного публичного redirect).

## 5. На что должен рассчитывать фронтенд

### 5.1 Endpoint `POST /pay` (двойной режим)
- **С admin Bearer token**: backend выполняет офлайн-оплату сотрудником и возвращает `204 No Content`.
- **Без admin Bearer token**: backend возвращает LiqPay payload (`200 OK`) и не меняет статус покупки до callback.

### 5.2 Endpoint `POST /public/purchase/{purchase_id}/pay`
- Возвращает LiqPay payload (`200 OK`) для публичной сессии покупки (cookie + CSRF).
- Также не меняет статус покупки до callback.

### 5.3 После редиректа с LiqPay
- Возврат пользователя на `result_url` **не является подтверждением оплаты**.
- Источник истины — серверный callback `POST /public/payment/liqpay/callback`.
- Фронтенд после возврата должен запрашивать актуальный статус покупки у backend и показывать пользователю финальный результат.

## 6. Callback от LiqPay
LiqPay отправляет уведомления о статусе платежа на серверный endpoint:

```
POST /public/payment/liqpay/callback
```

В теле запроса ожидаются поля `data` и `signature` (формат urlencoded или JSON). Бэкенд проверяет подпись, обновляет статус заказа
на `paid`, выпускает билеты и отправляет письмо с deep-link'ами по email покупателя. Статусы, отличные от `success`, `sandbox` или
`wait_accept`, возвращаются без изменения заказа.
